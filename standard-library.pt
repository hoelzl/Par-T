(herald "The Par-T-Standard-Library")

;;; Define this when we have a better continuation handling.
(define (error . args)
  (write args)
  (newline)
  args)

(define else #t)

(define (undefined)
  'the-undefined-value)

;;; Function Calling
;;; ================

(define (apply proc . args)
  (if (null? (cdr args))
      (%apply proc (car args))
      (%apply proc (%apply list* args))))


;;; List Functions
;;; ==============

(define (list . args)
  args)

(define (list* . args)
  (let chase ((args args))
    (cond ((null? args) '())
	  ((null? (cdr args)) (car args))
	  (else (cons (car args) (chase (cdr args)))))))

(define (cddr lst)
  (cdr (cdr lst)))

(define (first lst)
  (car lst))

(define (second lst)
  (cadr lst))

(define (third lst)
  (cadr (cdr lst)))

(define (fourth lst)
  (cadr (cddr lst)))

(define (rest lst)
  (cdr lst))

(define (rest2 lst)
  (cddr lst))

(define (ass pred object alist)
  (cond ((null? alist)
	 #f)
	((pred object (first (first alist)))
	 (first alist))
	(else 
	 (ass pred object (rest alist)))))

(define (assq object alist)
  (ass eq? object alist))

(define (assv object alist)
  (ass eqv? object alist))

(define (assoc object alist)
  (ass equal? object alist))


;;; Thie following definitions are taken from Tiny Clos.  They should
;;; be integrated with a more principled library.

(define (position-of x lst)
  (if (eq? x (car lst))
      0
      (+ 1 (position-of x (cdr lst)))))

(define (map-append proc . lists)
  (apply append (apply map (cons proc lists))))

(define (last lst)
  (if (null? lst)
      #f
      (if (null? (cdr lst))
	  (car lst)
	  (last (cdr lst)))))

(define (any? test . lists)
  (let scan ((tails lists))
    (if (member #t (map null? tails)) ; (any null? tails)
	#f
	(or (apply test (map car tails))
	    (scan (map cdr tails))))))

(define (every? test . lists)
  (let scan ((tails lists))
    (if (member #t (map null? tails)) ; (any null? tails)
	#t
	(and (apply test (map car tails))
	     (scan (map cdr tails))))))

(define (remove x list)
  (cond ((null? list) '())
	((eq? (car list) x) (cdr list))
	(else (cons (car list) (remove x (cdr list))))))

(define (getl plist name . not-found)
  (let scan ((tail plist))
    (cond ((null? tail)
	   (if (pair? not-found)
	       (first not-found)
	       (error "GETL couldn't find" name)))
	  ((eq? (first tail) name) (secodn tail))
	  (else (scan (rest2 tail))))))


(define (length list)
  (if (null? list)
      0
      (+ 1 (length (rest list)))))

(define (reverse lst)
  (if (null? lst)
      '()
      (cons (first lst) (reverse (rest lst)))))

(define (append lst1 lst2)
  (if (null? lst1)
      lst2
      (cons (first lst1)
	    (append (rest lst1) lst2))))

(define (map proc . lists)
  (let chase ((tails lists))
    (if (any? null? tails)
	'()
	(cons (apply proc (map first tails))
	      (chase proc (rest tails))))))

(define (for-each proc . lists)
  (let chase ((tails lists))
    (if (any? null? tails)
	(undefined)
	(begin
	  (apply proc (map first tails))
	  (chase proc (rest tails))))))


;;; Non-Deterministic Computation
;;; =============================

(define choice-points '())

(define (fail)
  (if (null? choice-points)
      (error "Fail without choice point.")
      (let ((next-choice (first choice-points)))
	(set! choice-points (rest choice-points))
	(next-choice))))

(define (create-choice-points . procs)
  (call/cc (lambda (cc)
	     (let ((new-cps (map (lambda (proc)
				   (lambda ()
				     (cc (proc))))
				 procs)))
	       (set! choice-points
		     (append new-cps choice-points)))
	     (fail))))
