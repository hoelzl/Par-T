(herald "The Par-T Test Suite")

(define (call/cc-test-01)
  (cons 1 (call/cc (lambda (cc)
		     (cons 2 '(3))))))

(define (call/cc-test-02)
  (cons 1 (call/cc (lambda (cc)
		     (cons 2 (cc '(3)))))))

(define (call/cc-test-03)
  (cons 1 (call/cc (lambda (cc)
		     (cons 2 (cons 3 (cc '())))))))

(define (call/cc-test-04)
  (let ((my-cont '()))
    (write
     (cons 1 (call/cc (lambda (cc)
			(set! my-cont
			      (lambda (x)
				(set! my-cont (lambda (y)
						(write (cons 'done y))
						(newline)))
				(cc x)))
			(cons 2 '(3))))))
    (newline)
    (my-cont '(foo))))

(define (call/cc-test-05)
  (let ((my-cont '()))
    (write
     (cons 1 (call/cc (lambda (cc)
			(set! my-cont
			      (lambda (x)
				(set! my-cont (lambda (y)
						(write (cons 'done y))
						(newline)))
				(cc x)))
			(cons 2 (cc '(3)))))))
    (newline)
    (my-cont '(foo))))

(define (call/cc-tests)
  (write (call/cc-test-01))
  (newline)
  (write (call/cc-test-02))
  (newline)
  (write (call/cc-test-03))
  (newline)
  (write (call/cc-test-04))
  (newline)
  (write (call/cc-test-05))
  (newline))

(define (boolean-values-test)
  (and (eq? #t #t)
       (eq? #f #f)
       (not (eq? #t #f))))

(define (if-test-01)
  (and (if #t #t #f)
       (if #f #f #t)))

(define (if-test-02)
  (and (if (not #t) #f #t)
       (if (not #f) #t #f)))

(define (if-test-03)
  (and (if 1 #t #f)
       (if '() #t #f)))

(define (type-predicate-test-pair)
  (and (pair? '(1 2))
       (not (pair? #f))
       (not (pair? 1))))

(define (type-predicate-test-null)
  (and (null? '())
       (not (null? #f))
       (not (null? '(1 2)))
       (not (null? 1))))

(define (type-predicate-test-boolean)
  (and (boolean? #t)
       (boolean? #f)
       (not (boolean? 1))
       (not (boolean? '()))))

(define (type-predicate-test-symbol)
  (and (symbol? 'foo)
       (not (symbol? "foo"))
       ;; This is a bug that's not easy to fix unless we define our
       ;; own symbol or list classes...
       ;; (not (symbol? '()))
       (not (symbol? #t))
       (not (symbol? #f))))

(define (core-language-test-begin)
  (and (eq? #f (begin))
       (eqv? 1 (begin 1))
       (eqv? 2 (begin 1 2))))


(define (core-language-test-closures-01)
  (let* ((make-adder (lambda (n)
		       (lambda (m)
			 (+ m n))))
	 (add-2 (make-adder 2))
	 (add-3 (make-adder 3)))
    (and (eqv? 5 (add-2 3))
	 (eqv? 6 (add-3 3)))))

;;; Tests for the standard library
;;; ==============================

(define (test-apply-01)
  (and (eq? (apply list) '())
       (eq? (apply list '()) '())))

(define (test-apply-02)
  (let ((result (apply list '(1 2 3))))
    (and (eqv? (first result) 1)
	 (eqv? (second result) 2)
	 (eqv? (third result) 3))))

(define (test-apply-03)
  (let ((result (apply list 1 2 '(3))))
    (and (eqv? (first result) 1)
	 (eqv? (second result) 2)
	 (eqv? (third result) 3))))


(define (test-list*)
  (let ((result (list* 1 2 '(3 4))))
    (and (eq? '() (list*))
	 (eqv? 1 (first result))
	 (eqv? 2 (second result))
	 (eqv? 3 (third result))
	 (eqv? 4 (fourth result)))))

(define (test-first-et-al)
  (let ((lst '(1 2 3 4 5 6 7)))
    (and (= 1 (first lst))
	 (= 2 (second lst))
	 (= 3 (third lst))
	 (= 4 (fourth lst))
	 (= 5 (fifth lst))
	 (= 6 (sixth lst)))))

(define (test-last)
  (and (eq? (last '()) #f)
       (eq? (last '(a)) 'a)
       (eq? (last '(a b)) 'b)))
	    

(define (test-assq)
  (let ((alist '((a . 1) (b . 2) (c . 3))))
    (and (pair? (assq 'a alist))
	 (eq? 'a (car (assq 'a alist)))
	 (eq? 1 (cdr (assq 'a alist)))
	 (eq? 'b (car (assq 'b alist)))
	 (eq? 2 (cdr (assq 'b alist)))
	 (eq? 'c (car (assq 'c alist)))
	 (eq? 3 (cdr (assq 'c alist)))
	 (eq? #f (assq 'x alist))
	 (eq? #f (assq 1 alist)))))

(define (test-position-of)
  (let ((lst '(a b c d)))
    (and (= (position-of 'a lst) 0)
	 (= (position-of 'b lst) 1)
	 (= (position-of 'c lst) 2)
	 (= (position-of 'd lst) 3)
	 (eq? #f (position-of 'e lst)))))

(define (test-any?-01)
  (not (any? identity '())))

(define (test-any?-02)
  (and (not (any? identity '(#f)))
       (any? identity '(#t))))

(define (test-map-01)
  (eq? (map (lambda (x) (+ x 1)) '()) '()))

(define (test-map-02)
  (let ((result (map (lambda (x) (+ x 1)) '(1 2 3))))
    (and (= (length result) 3)
	 (= (first result) 2)
	 (= (second result) 3)
	 (= (third result) 4))))

(define (test-map-03)
  (let ((result (map + '(1 2 3) '(3 2 1))))
    (and (= (length result) 3)
	 (= (first result) 4)
	 (= (second result) 4)
	 (= (third result) 4))))

(define (test-length)
  (and (= 0 (length '()))
       (= 1 (length '(1)))
       (= 2 (length '(1 2)))
       (= 3 (length '(1 2 3)))))

(define (test-reverse)
  (let ((result (reverse '(3 2 1))))
    (and (eq? '() (reverse '()))
	 (= 1 (first result))
	 (= 2 (second result))
	 (= 3 (third result)))))	 

(define (test-append-01)
  (let ((result (append '() '(1 2 3))))
    (and (= 3 (length result))
	 (= 1 (first result))
	 (= 2 (second result))
	 (= 3 (third result)))))

(define (test-append-02)
  (let ((result (append  '(1 2 3) '())))
    (and (= 3 (length result))
	 (= 1 (first result))
	 (= 2 (second result))
	 (= 3 (third result)))))

(define (test-append-03)
  (let ((result (append  '(1 2 3) '(4 5 6))))
    (and (= 6 (length result))
	 (= 1 (first result))
	 (= 2 (second result))
	 (= 3 (third result))
	 (= 4 (fourth result))
	 (= 5 (fifth result))
	 (= 6 (sixth result)))))

(define (test-map-append)
  (let* ((lst '((1 2) (3 4)))
	 (result (map-append (lambda (x)
			       (map (lambda (y) (+ 1 y)) x))
			     lst)))
    (and (= 4 (length result))
	 (= 2 (first result))
	 (= 3 (second result))
	 (= 4 (third result))
	 (= 5 (fourth result)))))


;;; Tests for the object system
;;; ===========================

(define (class-<class>-test)
  (and (%instance? <class>)
       (eq? <class> (%instance-class <class>))))


;;; Test Suites
;;; ===========

(define (boolean-tests)
  (display "Testing booleans")
  (newline)
  (write (list (boolean-values-test)
	       (if-test-01)
	       (if-test-02)
	       (if-test-03)))
  (newline))

(define (type-predicate-tests)
  (display "Testing type predicates")
  (newline)
  (write (list (type-predicate-test-pair)
	       (type-predicate-test-null)
	       (type-predicate-test-boolean)
	       (type-predicate-test-symbol)
	       ))
  (newline))

(define (core-language-tests)
  (display "Testing core language")
  (newline)
  (write (list (core-language-test-begin)
	       (core-language-test-closures-01)))
  (newline))

(define (standard-library-tests)
  (display "Testing standard library")
  (newline)
  (write (list (test-apply-01)
	       (test-apply-02)
	       (test-apply-03)
	       (test-list*)
	       (test-first-et-al)
	       (test-last)
	       (test-assq)
	       (test-position-of)
	       (test-any?-01)
	       (test-any?-02)
	       (test-map-01)
	       (test-map-02)
	       (test-map-03)
	       (test-length)
	       (test-reverse)
	       (test-append-01)
	       (test-append-02)
	       (test-append-03)
	       (test-map-append)))
  (newline))

(define (object-system-tests)
  (display "Testing object system")
  (newline)
  (write (list (class-<class>-test)))
  (newline))

(define (all-tests)
  (boolean-tests)
  (type-predicate-tests)
  (core-language-tests)
  (standard-library-tests)
  (object-system-tests))
